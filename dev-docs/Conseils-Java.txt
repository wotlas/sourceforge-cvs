Quelques règles de programmation Java
-------------------------------------

Contributeurs: Aldiss, Hari
Révision: 10 Juin 2001

Menu:

  1- La Visibilité
  2- Les exceptions
  3- Les tableaux
  4- La synchronisation
  5- Références Fantomes
  6- Design Patterns



Pour wotlas, il s'agit de faire un système stable et performant,
voici donc quelques recommandations importantes.


1 - LA VISIBILITE
-----------------

Quelques règles de visibilité/accès aux variables/méthodes de classes :

   a - les membres d'une classe doivent être "private" (s'il y a besoin de
       les accéder en R[/W] de l'extérieur, il faut implémenter un getter[/setter]).

       Pour les méthodes, il faut mettre l'accès le plus restrictif:

          - On choisit d'abord "private".

          - Si la méthode doit être accessible par d'autres classes du package on
            choisit default (rien), voir "protected" si la classe est faite pour être
            étendue.

          - Si vraiment la méthode doit être visible en-dehors du package, on met
            "public" mais dans ce cas le commentaire "javadoc" doit être suffisamment
            complet pour permettre son utilisation.
            => Pour la mise au point/maintenance cela se révèle fort utile !

   b - Pour les getter/setter, il faut de plus préciser qu'une méthode publique
       qui s'appelle "getXXX" doit en principe renvoyer la valeur de la propriété "XXX"
       en évitant au maximum les effets de bords (tout autre code peut être fondé à
       l'appeler sans se méfier).

       Exemple :

          PAS DE :

             Bob my_bob = new Bob( ... );            

              ....

              String s = null;

               try{
                    s = my_bob.getTabElement( i );   // je récupère le string à la position i

                    if( s.equals("null") )   // je corrige si c'est pas bon
                        s = "";
               }
               catch( ArrayOutOfBoudException e )
                  s = "";                       // je me suis planté dans la taille du tableau
               }                                // je corrige tant bien que mal...

              ...

             class Bob
             {

                 Object tab[] = new Object[10];

                 // Retourne la version "String" de l'élément du tableau
                    int getTabElement( int i ) {
                         return ""+tab[i];
                    }                    
             }


          MAIS :

             Bob my_bob = new Bob( ... );            

             ....

             String s = my_bob.getTabElement( i );

             ...

             class Bob
             {
                 Object tab[] = new Object[10];

               // Retourne la version "String" de l'élément du tableau
                  int getTabElement( int i ) {
                       if( tab[i]==null )
                           return "";

                     return ""+tab[i];
                  }
            }

  c - Il faut éviter que le "getXXX" fasse un traitement lourd en plus de renvoyer une valeur.
      Exemple à éviter :

            private MyData data;

            public MyData getData() {
                if (data == null) {
                  // On n'a pas les données, on cherche à les construire avec un
                  // traitement "lourd" qui impacte d'autres membres de la classe
                }

               return data;
            }

          Le problème de cette implémentation, c'est qu'un autre développeur peut
          croire qu'il peut tester la nullité ou non de "data" en appelant le getter,
          alors que cela va lui entraîner plein d'effets de bords.

          En général, celle-ci est préférable, même si elle nécessite 2 méthodes
          plutôt qu'une:

            private MyData data;

            /**
             * Provides the data or null if not yet computed.
             * Call computeData before if you want to be sure that the data
             * are available.
             * @return the data, possibly null.
             **/

              public MyData getData() {
                   return data;
              }

           /**
            * Provides the data.
            * (Possibly compute them if not yet done)
            * @return the data.
            **/

            public MyData computeData() {
                 if (data == null) {
                   // On n'a pas les données, on cherche à les construire avec un
                   // traitement "lourd" qui impacte d'autres membres de la classe
                 }

              return data;
            }



2 - LES EXCEPTIONS
------------------

* Le code suivant est à éviter :

    try{

       ....

    }
    catch(Exception e){
        // on ne fait rien
    }

  Il faut toujours traiter les exceptions ou alors les laisser se propager ( via throws ).
  De plus évitez autant que possible de capturer tous les types d'exceptions. Raffinez, raffinez...

  Pour le projet wotlas nous allons rajouter une classe wotlas.common.Debug qui contiendra
  des appels statiques du genre "declareError".

  Voici un exemple de code :

    try{

      ....

    }
    catch( UnknownHostException e ) {
        Debug.signal( Debug.ERROR, this, e );
    }


  Enfin dernier point, vous pouvez intercepter l'erreur suivante :

    try{
       int mon_tab[] = new int[1000000];
       ....
    }
    catch( OutOfMemoryError e ) {
        Debug.signal( Debug.ERROR, this, e );
        ....
    }

  Ce qui peut-être utile par exemple côté serveur lors de la création de gros objets.


3 - LES TABLEAUX
----------------

* PAS DE VECTOR ! Sauf éventuellement côté client pour des classes peu importantes.
  Un Vector c'est 40 FOIS plus lent qu'un simple tableau.

  A la place il y a :

     - pour gérer un grand nombre d'éléments : les java.util.HashMap 
       Ce sont des tables à accès direct (via une clé et méthode de hachage)
       Les accès sont non "synchronised".

    - les java.util.HashTable. Pareil que les HashMap mais les accès sont "synchronized"
      donc plus lent.

    - les tableaux tous simples... pour un nombre d'éléments bornés et peu important.

    - les tableaux avec recopie... pour un nombre d'éléments non borné mais peu important.

      Exemple d'implémentation :

      Objet pile[] = new Objet[10];
      int dernier_element;

       void rajouter( Objet element )
       {
          if( dernier_element+1 == pile.length ) {
              Objet pile_tmp[] = new Objet[ pile.length + 5 ];

              System.arraycopy( pile, 0, pile_tmp, 0, pile.length );
              pile = pile_tmp;
          }

         dernier_element++;
         pile[dernier_element] = element;
       }

      Notez l'utilisation de la fonction système de recopie de tableaux d'objets. Il n'y a
      pas plus rapide pour faire des recopies ! (appel système à bcopy)

    - il y a aussi les java.util.ArrayList. Ce sont comme des Vector mais non synchronisés.
      Ils sont encore 10 fois plus lents que les tableaux.


4 - LA SYNCHRONISATION
----------------------

* Attention aux synchronized ! Bien utilisé c'est très puissant... mal utilisé c'est une catastrophe pour les performances ! Pensez à bien séparer les domaines de synchronisation. Jettez un coup d'oeil à l'exemple suivant:

  class MonExemple1
  {
     private int bob;
     private int tony;

     synchronized public int getBob(){
        return bob;
     }

     synchronized public void setBob( int val){
        bob = val;
     }

     synchronized public int getTony(){
        return tony;
     }

     synchronized public void setTony( int val){
        tony = val;
     }
  }

Ici le synchronized est sur l'appel de méthode. Le lock considéré est celui de l'instance courante de MonExemple1. Un appel à getTony() va bloquer si setBob() est appelé... même si ce n'est pas trop grave ici (les traitements sont courts) c'est un peu bête puisque les variables tony/bob n'ont rien en commun. Une deuxième solution bien meilleure est la suivante :

  class MonExemple2
  {
     private int bob;
     private Object lock_bob = new Object();

     private int tony;
     private Object lock_tony = new Object();

     public int getBob(){
        synchronized( lock_bob ) {
           return bob;
        }
     }

     public void setBob( int val){
        synchronized( lock_bob ) {
           bob = val;
        }
     }

     public int getTony(){
        synchronized( lock_tony ) {
           return tony;
        }
     }

     public void setTony( int val){
        synchronized( lock_tony ) {
           tony = val;
        }
     }
  }
  
Bon là je suis d'accord c'est un peu extrème dans cet exemple. Mais c'est juste pour souligner l'importance de la séparation des domaines de concurrence d'accès.



5 - REFERENCES FANTOMES
-----------------------

Ce sont des références à des objets qui ne sont plus utilisés mais qui existent encore en mémoire.
En effet le garbage collector compte le nombre de références sur un objet, et attend que ce nombre passe à 0 pour déclarer l'objet "Mort" et récupérer plus tard la mémoire. Donc dans le cas suivant :

    void fonction()
    {
      MonObjet obj = new MonObjet();

      ... du code ...

       obj = null;       <= signale que la place mémoire prise par obj peut être libérée !

      ... du code ...
    }

Ca c'est un cas simple car on peut aussi attendre la fin de la fonction pour que la variable
locale soit effacée... là où ça se complique c'est si on utilise des HashTable ou des tableaux.

Dans ces cas on peut oublier d'effacer des anciennes références, les objets ne sont pas effacés et au bout d'un moment c'est le "Exit: Out Of Memory"... donc attention aux références d'objets ! n'hésitez pas à faire des obj=null , ça n'a rien de ridicule.


6 - DESIGN PATTERNS
-------------------

Voici brivèment quelques motifs de programmation orientée objet. Vous les connaissez sans doute mais ça ne fait pas de mal de les rappeler.

 * Nom: Singleton
   But: Limiter l'utilisation d'un objet à une seule instance. Le principe peut être étendu au contrôle
        de création d'objets.

   Code:

      class MaClasse{

         private static MaClasse maclasse;  // unique instance de la classe

         private MaClasse( ... ){         // constructeur privé
            ....
         }

         public static MaClasse createMaClasse( ... ){
              if(maclasse==null)
                  maclasse = new MaClasse( ... );
 
            return maclasse;
         }

         public static MaClasse getDefaultMaClasse( ... ){
            return maclasse;
         }
      }

  * Nom: Factory
    But: Déléguer la création d'objets génériques à un objet "Factory" qui sait quelles types d'objets créer.
         On centralise ainsi toute l'intelligence de création d'objets. Il y a de nombreux types de Factory
         (cf. littérature). Une factory est généralement un bon exemple de singleton.
         ( un exemple plus détaillé de factory se trouve dans wotlas.libs.net.NetMessageFactory ).
 
    Code:

      class MaMessageFactory{

         private static MaMessageFactory ma_factory;

         public Message getMessageInstance( int id ){    // méthode de création

             switch( id ) {
                case MESSAGE_BOB:
                      return (Message) new MessageBob();

                case MESSAGE_STRING:
                      return (Message) new MessageString();

                default:
                      return null;
             }
         }
      }

  * Nom: Façade
    But: Masquer la complexité d'un package/groupe de classes en proposant une classe qui sert de point d'entrée.
         Les avantages principaux sont en contrôle et en maintenabilité : vu que tout le monde utilise le même point
         d'entrée on peut effectuer de nombreux changements sur les classes métiers qu'il y a derrière sans que
         cela gène les utilisateurs.

    Code:

      classe MaFaçade {

          MonObjetTechnique1 obj_tech_1;
          MonObjetTechnique1 obj_tech_2;
          MonObjetTechnique1 obj_tech_3;

          int appelIznogoud() {
              return obj_tech_1.appelIznogoud();
          }

          int appelBozo() {
              return obj_tech_2.appelBozo();
          }

          void faireTraitementTony( int val ) {

              if( val==1 )
                 obj_tech_2.recevoirCadeauxTony();
              else
                 obj_tech_3.acheterCadeauxTony();              
          }
      }


  * Nom: Observateur (type listener)

  * Nom: Composite  (listes chainées...)

    et bien d'autres... à suivre...
